"""Utility functions for tests."""
import os
import subprocess
import tarfile
from contextlib import contextmanager
from glob import glob
from gzip import GzipFile
from io import BytesIO

import nibabel as nb
import numpy as np
import requests
from bids.layout import BIDSLayout


def download_test_data(dset, data_dir=None):
    """Download test data."""
    URLS = {
        "examples_pasl_multipld": (
            "https://upenn.box.com/shared/static/njb5tqs2n53775qumtwc1wyxo5362sp7.tar.gz"
        ),
        "examples_pcasl_multipld": (
            "https://upenn.box.com/shared/static/pm0ysafvg69jimk1bcm3ewtljiwzk899.tar.gz"
        ),
        "examples_pcasl_singlepld": (
            "https://upenn.box.com/shared/static/il6cfea6f0wjnmjjvcpg6baw3e7yrwa3.tar.gz"
        ),
        "test_001": "https://upenn.box.com/shared/static/cudw5yyh3j6jwymmlzdw2nwc6knmxdu9.tar.gz",
        "test_002": "https://upenn.box.com/shared/static/wpuvn06zl4v5nwd9o8tysyfs3kg4a2p0.tar.gz",
        "test_003": "https://upenn.box.com/shared/static/1c64kn7btb5dodksnn06wer2kfk00px5.tar.gz",
    }
    if dset not in URLS:
        raise ValueError(f"dset ({dset}) must be one of: {', '.join(URLS.keys())}")

    if not data_dir:
        data_dir = os.path.join(get_test_data_path(), "test_datasets")

    out_dir = os.path.join(data_dir, dset)

    if os.path.isdir(out_dir):
        print(
            f"Dataset {dset} already exists. "
            "If you need to re-download the data, please delete the folder."
        )
        return out_dir

    os.makedirs(out_dir, exist_ok=True)
    with requests.get(URLS[dset], stream=True) as req:
        with tarfile.open(fileobj=GzipFile(fileobj=BytesIO(req.content))) as t:
            t.extractall(out_dir)

    return out_dir


def get_test_data_path():
    """Return the path to test datasets, terminated with separator.

    Test-related data are kept in tests folder in "data".
    Based on function by Yaroslav Halchenko used in Neurosynth Python package.
    """
    return os.path.abspath(os.path.join(os.path.dirname(__file__), "data") + os.path.sep)


def check_generated_files(out_dir, output_list_file):
    """Compare files generated by aslprep with a list of expected files."""
    aslprep_dir = os.path.join(out_dir, "aslprep")
    found_files = sorted(glob(os.path.join(aslprep_dir, "**/*"), recursive=True))
    found_files = [os.path.relpath(f, out_dir) for f in found_files]

    # Ignore figures
    found_files = [f for f in found_files if "figures" not in f]

    # Ignore logs
    found_files = [f for f in found_files if "log" not in f.split(os.path.sep)]

    with open(output_list_file, "r") as fo:
        expected_files = fo.readlines()
        expected_files = [f.rstrip() for f in expected_files]

    if sorted(found_files) != sorted(expected_files):
        expected_not_found = sorted(list(set(expected_files) - set(found_files)))
        found_not_expected = sorted(list(set(found_files) - set(expected_files)))

        msg = ""
        if expected_not_found:
            msg += "\nExpected but not found:\n\t"
            msg += "\n\t".join(expected_not_found)

        if found_not_expected:
            msg += "\nFound but not expected:\n\t"
            msg += "\n\t".join(found_not_expected)
        raise ValueError(msg)


def check_affines(data_dir, out_dir, input_type):
    """Confirm affines don't change across XCP runs."""
    fmri_layout = BIDSLayout(str(data_dir), validate=False, derivatives=False)
    xcp_layout = BIDSLayout(str(out_dir), validate=False, derivatives=False)
    if input_type == "cifti":  # Get the .dtseries.nii
        denoised_files = xcp_layout.get(
            invalid_filters="allow",
            datatype="func",
            run=1,
            extension=".dtseries.nii",
        )
        space = denoised_files[0].get_entities()["space"]
        bold_files = fmri_layout.get(
            invalid_filters="allow",
            datatype="func",
            run=1,
            space=space,
            extension=".dtseries.nii",
        )

    elif input_type == "nifti":  # Get the .nii.gz
        # Problem: it's collecting native-space data
        denoised_files = xcp_layout.get(
            datatype="func",
            run=1,
            suffix="bold",
            extension=".nii.gz",
        )
        space = denoised_files[0].get_entities()["space"]
        bold_files = fmri_layout.get(
            invalid_filters="allow",
            datatype="func",
            run=1,
            space=space,
            suffix="bold",
            extension=".nii.gz",
        )

    else:  # Nibabies
        denoised_files = xcp_layout.get(
            datatype="func",
            space="MNIInfant",
            suffix="bold",
            extension=".nii.gz",
        )
        bold_files = fmri_layout.get(
            invalid_filters="allow",
            datatype="func",
            space="MNIInfant",
            suffix="bold",
            extension=".nii.gz",
        )

    bold_file = bold_files[0].path
    denoised_file = denoised_files[0].path

    if input_type == "cifti":
        assert (
            nb.load(bold_file)._nifti_header.get_intent()
            == nb.load(denoised_file)._nifti_header.get_intent()
        )
    else:
        if not np.array_equal(nb.load(bold_file).affine, nb.load(denoised_file).affine):
            raise AssertionError(f"Affines do not match:\n\t{bold_file}\n\t{denoised_file}")

    print("No affines changed.")


def run_command(command, env=None):
    """Run a given shell command with certain environment variables set."""
    merged_env = os.environ
    if env:
        merged_env.update(env)
    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        shell=True,
        env=merged_env,
    )
    while True:
        line = process.stdout.readline()
        line = str(line, "utf-8")[:-1]
        print(line)
        if line == "" and process.poll() is not None:
            break

    if process.returncode != 0:
        raise Exception(
            f"Non zero return code: {process.returncode}\n" f"{command}\n\n{process.stdout.read()}"
        )


@contextmanager
def chdir(path):
    """Temporarily change directories.

    Taken from https://stackoverflow.com/a/37996581/2589328.
    """
    oldpwd = os.getcwd()
    os.chdir(path)
    try:
        yield
    finally:
        os.chdir(oldpwd)
